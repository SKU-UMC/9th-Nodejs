# Chapter 1. Database 설계- 데이터베이스 기초

데이터베이스는 언제 설계를 해야 할까요?

데이터베이스의 설계 결과물은 **ERD**이며,
ERD를 그리는 툴은 선호도에 따라 다르니 마음에 드시는 툴을 선택하시면 됩니다.

TMI) 저(🐕똘이🐕) 같은 경우는 StarUML과 AQueryTool을 사용합니다!

(기능은 별로 안 좋지만 간단하게 실시간으로 팀원들과 함께 실시간으로 수정할 때는 ERD Cloud를 사용하기도 합니다.) (무엇보다 무료여서… 💵)

자, 그러면 ERD는 언제 설계하는 것이 좋을까요?

<aside>
🌟 **ERD는 프로젝트 시작과 동시에 설계하는 것이 좋습니다.**

물론, 기획과 디자인이 어느 정도 나와 개발자가 작업을 시작할 수 있는 시점을 말하는 것입니다.

</aside>

ERD는 세세한 내용은 언제든지 바뀔 수 있기에 **처음부터 완벽하게 만들 필요는 없습니다.**

큰 틀을 정해두는 것이 **1차 목표**이며,
보통 실제 기능 구현을 진행하며 필요한 내용을 수정하죠.

그리고 **서버 파트 챌린저들이 명심해야 하는 것**은

<aside>
❗ **모든 팀원이 인지하는 데이터베이스는 동일해야 한다는 것입니다.**

**각자 자기 마음대로 DB를 설계하고, 작업 후 나중에 합치는 행위는 매우 좋지 않습니다.**

꼭 처음에 빠르게 ERD를 설계하여,
**모두가 공통된 데이터베이스에 대해 인지한 후 작업을 하는 것**이 좋습니다!

</aside>

> 이번 주 **워크북**은
> 
> - **유저 테이블을 어떻게 설계**하는 것이 좋은지
> - **N : M(다대다) 관계는 어떻게 하는 것**이 좋은지
> - **알림을 보내야 하는 경우**는 어떻게 하는 것이 좋은지 등
> 
> **설계를 할 때 이런 식으로 하는 것이 좋다**는 것에 대한 내용을 다룹니다.
> 

> 미리 말씀드리지만, 이번 주차 **미션**은
저희 💛**Plan 파트**💛에서 제공해주신 피그마(IA/WF)를 보고,
**직접 설계를 해보는 것** 입니다!
> 
> 
> 그리고 **추가적으로 AWS에서 로컬 DB를 구축하는 것도 진행할 예정**입니다.
> 

🤓 저희 UMC 스터디에서는 **MySQL을 기준**으로 한다는 점을 말씀드립니다. 🤓

# DATABASE 설계

---

아래 도서 대여 관리 app에 대한 😉**아주 간단한 요구 사항**😉을 살펴봅시다.

## 요구 사항

---

### 사용자 관련 요구 사항

1. **카카오 소셜 로그인**을 구현 할 예정이다.
2. **회원 탈퇴 기능**이 필요하다.
3. **이름, 닉네임, 전화번호, 성별**이 필요하다.

### 책 관련 요구 사항

1. **사용자가 책 여러 권을 대여**할 수 있다.
2. 책은 **하나의 카테고리**가 있다.
3. 책은 **제목, 설명에 대한 정보**가 필요하다.
4. 책 소개 페이지에 **해시태그**가 붙을 수 있고,
**책 한 권에 해시태그 여러 개**가, **해시태그 하나가 여러 책**에 붙을 수 있다.
5. 사용자가 책 설명 페이지에서 책에 **좋아요**를 누를 수 있다.
6. 책 **카테고리 별로 현재 몇 개의 책이 있는지 집계**가 필요하다.

### 알림 관련 요구 사항

1. 알림은 **공지 관련 알림, 책 반납 시간 임박 알림, 마케팅 알림이 있을 수 있다.**

## 한 번 먼저 어떻게 설계할지 고민 해보세요!

---

- **꼭 혼자 고민해본 후, 열어서 읽어주세요!**
    
    데모데이를 준비하며 협업용으로 Erd Cloud를 많이 사용하니 저희도 Erd Cloud를 한번 사용해 보겠습니다. 가입 절차도 간단하니 실습도 Erd Cloud나, 다른 좋은 도구가 있다면 그걸 사용해서 하시는 것을 추천드려요! 
    
     
    
    우선 저렇게 간단히 구상을 했다고 해봅시다.
    
    ![image.png](Chapter%201%20Database%20%EC%84%A4%EA%B3%84-%20%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%20%EA%B8%B0%EC%B4%88%202748c5ff891781c1b622df95c3a784df/image.png)
    
    1. 먼저, **테이블 이름과 칼럼 이름은 모두 소문자**,
    그리고 **단어 구분은 대소문자가 아닌, 밑줄로 구분**을 해주는 것이 좋습니다.
    **꼭 이름을 이 규칙**으로 지어주세요!
    2. 기본 키를 위해 **각 엔티티 정보 중 유일한 값을 기본 키로 설정하기 보다는 index를 따로 두는 것이 편합니다!**
    그리고 **각 index를 위한 id를 book_id, member_id 이렇게 보다는
    그냥 id로 이름을 짓는 것이 좋아요!**
    3. **기본 키 타입은 int가 아닌 추후 서비스 확장을 고려해서 bigint**로 해주세요!
    
    이제 그러면 아래처럼 되겠죠
    
    ![image.png](Chapter%201%20Database%20%EC%84%A4%EA%B3%84-%20%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%20%EA%B8%B0%EC%B4%88%202748c5ff891781c1b622df95c3a784df/image%201.png)
    
    자 이제 각각 타입을 뭐로 해야 할까요?
    
    사실 **타입은 PM에게 물어봐야 확실히 결정이 가능**합니다!
    
    따라서 DataBase 설계를 하면서 부끄러워하지 말고,
    **PM에게 지속적으로 물어보세요!**
    
    <aside>
    🔥 **와이어 프레임이 있다고 해도 헷갈리는 부분은
    ❗꼭❗ 적극적으로 물어보세요!
    그냥 그렇겠지.. 하고 넘어가게 된다면 추후에 수정 지옥을 맛보게 됩니다.**
    
    </aside>
    
    ![image.png](Chapter%201%20Database%20%EC%84%A4%EA%B3%84-%20%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%20%EA%B8%B0%EC%B4%88%202748c5ff891781c1b622df95c3a784df/image%202.png)
    
    저는 타입을 일단 위와 같이 하겠습니다.
    
    MySQL에서 varchar(20)는 최대 20글자인데, 유니코드 기준 20글자니, 한글 20글자로 생각하셔도 됩니다!
    
    그리고 description의 경우 text 타입은 String과 같이 길이 제한이 없는 타입인데 저는 예시를 위해 저렇게 한 것이고,
    
    **PM과 상의를 해서 글자 수 제한을 얼마로 줄지 결정**을 하시는 것이 좋습니다!
    
    다음으로 member 테이블에서 **gender의 경우**
    
    - **0이면 남자, 1이면 여자** 이렇게 하는 경우도 있고,
    - 저렇게 **varchar로 설정하여, 문자로 두고 enum으로 관리**를 해도 됩니다!
    
    이제 위의 세 테이블을 더 꼼꼼하게 설계 해봅시다.
    
    ![image.png](Chapter%201%20Database%20%EC%84%A4%EA%B3%84-%20%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%20%EA%B8%B0%EC%B4%88%202748c5ff891781c1b622df95c3a784df/image%203.png)
    
    위 처럼 created_at, 그리고 updated_at을 테이블마다 추가해주는 것이 좋고
    
    datetime(6)에서 (6)은 밀리초 소수점 6자리까지 구분한다는 의미입니다.
    
    ### 🤔 왜 밀리초까지 구분하죠?
    
    사실 이는 나중에 기능 구현을 염두한 설계입니다.
    **최신순 정렬** 기능은 정말 흔한 기능입니다.
    
    근데 초 단위까지만 저장을 하게 된다면 어떤 일이 일어날까요?
    동시에 책을 등록하여 created_at이 초 단위까지 같은 상황이 일어난다면?
    
    그럴 경우 최신순 정렬이 잘 안되기에, 밀리초 소수점까지 구분하는 것입니다.
    
    참고로 MySQL 기준 6자리가 최대입니다.
    
    ![image.png](Chapter%201%20Database%20%EC%84%A4%EA%B3%84-%20%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%20%EA%B8%B0%EC%B4%88%202748c5ff891781c1b622df95c3a784df/image%204.png)
    
    member 테이블은 그리고 위처럼 status와 inactive_date를 두는 것이 좋습니다.
    
    ### 🤔 왜 저렇게 할까요?
    
    사실 기능 구현 시 **회원 탈퇴, 게시글 삭제** 등의 연산을
    **HTTP Method 중 Delete로 바로 삭제**를 해 버리는 방법도 있을 것입니다.
    
    이를 **Hard Delete**라고 부릅니다.
    
    허나, **위의 방법(Hard Delete)은 지양**하는 것이 좋습니다.
    
    게시글은 요구 사항에 따라 다르겠지만, 유저의 경우
    
    예시를 들어보자면 인스타그램의 경우, 회원 탈퇴를 철회하고 다시 돌아오는 회원들이 존재합니다.
    
     ~~갑자기 현타와서 회원 탈퇴하고 7일 만에 다시 돌아와 보셨나요….털석🥲~~
    
    그리고 아래와 같은 요구사항이 있다고 해봅시다.
    
    > ***매일 인기가 있는 사용자 상위 5명을 집계해서 보여줘야 한다.
    근데 이 때 join 연산으로 가져와서 보여주도록 되어있는 상태***
    > 
    
    이 때, 상위 1등이 갑자기 탈퇴를 하고 Delete로 그 자리에서 삭제를 하게 된다면 어떻게 될까요?
    
    ***갑자기 1등은 없고 2 3 4 5등만 존재하게 되는 것이죠.***
    
    사실 저 부분도 요구 사항에 따라 다르긴 합니다.
    근데 저걸 좋아하는 PM은 없지 않을까…. 싶습니다.
    
    따라서 사용자 같이 곧바로 지워버리는 것이 위험한 엔티티는 바로 Delete를 하는 것이 아니라
    
    <aside>
    ☝ **일단 비활성 상태로 두고, 일정 기간동안 비활성인 경우 자동 삭제가 되도록**
    
    </aside>
    
    설계 하는 것이 좋습니다!
    
    이 때, **status를 active, inactive등 enum으로 관리**를 하기 위해 **varchar(15)로 둔 것이고,
    경우에 따라 0이면 비활성, 1이면 활성** 이렇게 해도 됩니다.
    
    그리고 **얼마 동안 비활성 된 상태인지 알아내기 위해 inactive_date**를 따로 두는 것입니다.
    
    ### 🤔 그러면 어떻게 자동으로 지우나요?
    
    이를 위해서는 **batch**라는 것을 알아야 합니다.
    
    **batch란 정해진 시간에 자동으로 실행되는 프로세스**인데,
    
    단적인 예로 매일 새벽 2시에 자동으로 member 테이블을 검사하여
    inactive된 이후 7일이 지난 경우 삭제하도록 할 수 있죠.
    
    > ***그리고 이를 soft delete라고 부릅니다***
    > 
    
    꼭 회원 뿐만 아니라,
    요구 사항에 휴지통 기능(삭제 했다가 복구)이 있는 경우도
    바로 delete를 하면 안되고, ***soft delete***를 해야 합니다.
    
    그리고 soft delete는 당연히 HTTP Method 중 **Patch**입니다!
    
    ### 🤔 연관 관계에 대한 고민
    
    MySQL은 RDB 기반이고, RDB에서는 외래 키로 연관 관계를 표시하죠? 
    
    (여기서 RDB란 관계형 데이터베이스, **Relational Database**를 의미합니다) 
    
    - 요구 사항 다시 보기
        
        ### 사용자 관련 요구 사항
        
        1. 회원 탈퇴 기능이 필요하다
        2. 이름, 닉네임, 전화번호, 성별 정보가 필요하다.
        
        ### 책 관련 요구 사항
        
        1. 사용자가 책 여러 권을 대여할 수 있다.
        2. 책은 하나의 카테고리가 있다.
        3. 책은 제목, 설명에 대한 정보가 필요하다.
        4. 책 소개 페이지에 해시 태그가 붙을 수 있고 책 한권에 해시태그 여러개가, 해시태그 
            
            하나가 여러 책에 붙을 수 있다.
            
        5. 사용자가 책 설명 페이지에서 책에 좋아요를 누를 수 있다.
        6. 각 책마다 몇 개의 좋아요를 받았는지 집계가 필요하다.
        7. 책 카테고리 별로 현재 몇개의 책이 있는지 집계가 필요하다.
        
        ### 알림 관련 요구 사항
        
        1. 알림은 공지 관련 알림, 마케팅 알림이 있을 수 있다.
    
    여기서 **사용자가 책을 대여할 때**,
    이때는 **연관 관계를 어떻게** 해야 할까요?
    
    ❓ ***사용자랑 책이랑 1 : N ???*** ❓
    
    다시 생각을 해보면 저 테이블에서 book은 책 종류를 말하는 것이지
    실제 책 한 권을 얘기하는 건 아니잖아요.
    
    한 종류의 책을 여러 사용자가 대여하고, 한 사용자가 여러 종류의 책을 대여할 수 있으니
    
    ***이 때 사용자와 책은 N : M 관계입니다.***
    
    ### 🤔 이럴 땐 어떻게 하나요?
    
    **N : M 관계**일 때는 **가운데에 매핑 테이블을 따로 둬야 합니다.**
    
    ![image.png](Chapter%201%20Database%20%EC%84%A4%EA%B3%84-%20%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%20%EA%B8%B0%EC%B4%88%202748c5ff891781c1b622df95c3a784df/image%205.png)
    
    가운데 매핑 테이블은 양쪽의 기본 키를 외래 키로 가지고,
    각각과 1 : N 관계를 가집니다.
    
    ### 🤔 책과 책 카테고리의 경우, 어떻게 관계를 매핑할까?
    
    현재 요구 사항에서는 책에 카테고리 한 종류만 붙습니다.
    카테고리 하나 당 그저 여러 종류의 책이 관계를 가지기에,
    **카테고리와 책이 1 : N 관계**입니다.
    
    그러나, **책 한 종류에 여러 카테고리**가 붙을 수 있다면??
    → **N : M 관계**이므로 당연히 가운데 매핑 테이블을 둬야 합니다.
    
    ### 🤔 책에 붙는 해시태그는? 사용자가 책에 누르는 좋아요는
    
    이제 감 오시겠지만,
    
    <aside>
    1️⃣ **해시태그도 여러개가 한 책에 붙고, 책에 여러 해시태그가 붙기에
    N : M 관계**입니다.
    
    </aside>
    
    <aside>
    2️⃣ 마찬가지로 **한 종류의 책에 사용자 여러명이 좋아요를 누르고, 한 사용자가 여러 책에 좋아요를 누르기에
    이 역시 N : M 관계**입니다.
    
    </aside>
    
    따라서 아래와 같이 설계가 가능합니다.
    
    ![image.png](Chapter%201%20Database%20%EC%84%A4%EA%B3%84-%20%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%20%EA%B8%B0%EC%B4%88%202748c5ff891781c1b622df95c3a784df/image%206.png)
    
    ### 🤔 알림의 경우는 어떻게 설계할까요?
    
    알림은 살짝 골 때리는 설계입니다. 🥲
    
    알림은 어떤 점이 짜증이 날까요?
    
    아래와 같은 요구 사항이 붙으면 좀 짜증 나게 됩니다. 🤬
    
    ***공지 사항에 대한 알림은 알림 터치 시 해당 공지 사항으로 이동이 되고,***
    
    ***마케팅 알림의 경우 터치 시 해당 마케팅으로 이동이 된다.***
    
    이제 여기서 설계를 하려고 하면 잠깐 사고의 정지가 옵니다.
    
    😱 ***어…. 어떤 것에 대한 알림인지 어떻게 알아내지…?*** 😱
    
    이에 대해서는 **3가지 설계 방법**이 있습니다.
    
    1. **슈퍼 타입과 서브 타입의 구성**
        
        이런 모양으로 설계를 할 수 있습니다.
        
        ![1. 슈퍼 타입과 서브 타입의 구성](Chapter%201%20Database%20%EC%84%A4%EA%B3%84-%20%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%20%EA%B8%B0%EC%B4%88%202748c5ff891781c1b622df95c3a784df/image%207.png)
        
        1. 슈퍼 타입과 서브 타입의 구성
        
    2. **하나의 테이블에 두고 dtype으로 구분**
        
        간단하게 **모든 내용을 다 한 테이블에 두고 dtype으로 구분을 하는 방법**이 있습니다.
        
        이 때 dtype을 테이블로 따로 관리를 하거나 enum으로 관리하는 것은 **선택**하시면 됩니다.
        
        ![2. 하나의 테이블에 두고 dtype으로 구분 ](Chapter%201%20Database%20%EC%84%A4%EA%B3%84-%20%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%20%EA%B8%B0%EC%B4%88%202748c5ff891781c1b622df95c3a784df/image%208.png)
        
        2. 하나의 테이블에 두고 dtype으로 구분 
        
    3. **그냥 테이블 다 나누기**
        
        ![3. 그냥 테이블 다 나누기 ](Chapter%201%20Database%20%EC%84%A4%EA%B3%84-%20%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%20%EA%B8%B0%EC%B4%88%202748c5ff891781c1b622df95c3a784df/image%209.png)
        
        3. 그냥 테이블 다 나누기 
        
    
    ### ***fin*** 마지막, 구현을 고려한 설계 예시
    
    사실 데이터베이스는 위에서도 말했지만
    **처음부터 완벽하게 설계를 할 수는 없습니다.**
    
    그러나 경험이 쌓임에 따라 미래를 예측하여
    아, 이렇게 했다가 나중에 다시 바꾸겠지… 하는 부분이 있습니다.
    
    요구 사항 중
    
    사용자가 책에 좋아요를 누를 수 있고 이를 집계를 한다고 했잖아요?
    
    ***이럴 때 책 테이블에 likes 칼럼을 두고 좋아요를 집계하는 것이 좋을까요?***
    
    ***좋아요를 누르면 + 1, 취소하면 -1 이렇게?***
    
    뭐… 큰 무리는 없지만 아래의 요구 사항이 추가된다면 어떻게 될까요?
    
    ***사용자 간 차단 기능이 생기게 되어 차단 한 사용자가 누른 좋아요는 집계를 하지 않는다.***
    
    이럴 때는 어떻게 해야 할까요? 차단 한 경우마다 좋아요를 -1을 해야 하나??
    
    사실, 저런 경우를 대비해
    
    **좋아요 개수를 집계하는 것**은
    
    <aside>
    🌟 ***순수 DML 연산으로, book_likes에서 해당 책 아이디를 가진 것이 몇 개인지 직접 세는 것이 좋습니다.***
    
    </aside>