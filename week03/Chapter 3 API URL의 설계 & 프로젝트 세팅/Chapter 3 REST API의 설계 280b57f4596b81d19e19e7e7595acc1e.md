# Chapter 3. REST API의 설계

## REST API

REST는 Representational State Transfer의 약자로,

HTTP를 기반으로 하는 웹 서비스 아키텍처를 의미하며
HTTP 메소드와 자원을 이용해 서로 간의 통신을 주고받는 방법입니다.

## API Endpoint

REST API에서 API Endpoint는 해당 API를 호출하기 위한 HTTP 메소드, 그리고 URL을 포함합니다.

## HTTP 메소드

HTTP 메소드는 REST 방식으로 통신 할 때 필요한 작업을 표시하는 방법으로

여러 가지가 있지만 아래의 5가지만 소개를 하겠습니다.

그리고 아래의 5개 메소드는 CRUD(생성, 조회, 갱신, 삭제) 4가지에 대응이 됩니다.

| **CRUD** | **HTTP 메소드** |
| --- | --- |
| **C**reate | **POST**(데이터 생성) |
| **R**ead | **GET**(데이터 조회) |
| **U**pdate | **PUT**,**PATCH**(데이터 수정)
***PUT은 전체, PATCH는 일부* |
| **D**elete | **DELETE**(데이터 삭제) |

위의 5개 메소드 중 **POST**는 **새로운 자원의 생성**도 있지만,
클라이언트가 **특정 정보를 서버로 넘기고 그에 대한 처리를 요청 하는 것**을
전부 POST로 처리 가능합니다.

## RESTful API Endpoint의 설계

이제 RESTful한 API의 설계를 위한 규칙을 알아봅시다.

RESTful한 API의 Endpoint는 **아래의 규칙**에 따라 설계가 가능합니다.

1. URI에 **동사가 포함이 되어선 안된다.**
2. URI에서 **단어의 구분이 필요한 경우 -(하이픈)을 이용**한다.
3. **자원**은 기본적으로 **복수형으로 표현**한다.
4. 단 하나의 자원을 **명시적으로 표현**을 하기 위해서는 **/users/id와 같이 식별 값을 추가로 사용**한다.
5. **자원 간 연관 관계가 있을 경우 이를 URI에 표현한다.**

5번은 추가적인 설명이 필요하나 나머지는 쉽게 감이 올 것입니다.

이제 예시를 보면서 REST API 설계를 어떻게 하는지 살펴봅시다.

### 회원 가입, 로그인, 탈퇴

사실 API URL Endpoint 설계가 **가장 난해한 경우**인데요, 

우선 로그인의 경우가 가장 애매합니다.

먼저 로그인의 주체가 되는 대상은 사용자이므로

url 상에 users가 들어가는 것은 쉽게 감이 옵니다.

그런데 그 이후가 난해하죠. 😱

우선 클라이언트가 로그인에 필요한 정보를 서버로 넘겨 로그인에 대한 처리를 요청하는 것이니 

**POST로 설계**를 해야겠죠.

그러나 여기서 **POST /users 이렇게 하면 될까요?**

**회원 가입 역시 새로운 사용자의 생성이기 때문에 POST /users로 표현이 가능**합니다.

따라서 **회원 가입의 경우가 있기 때문에 로그인을 POST /users로 표현하기가 힘들죠.**

이런 경우에는 **너무 타이트하게 RESTful 한 API 설계를 따르려고 하지 않아도 됩니다.**

<aside>
🤩 ***POST /users/login***

</aside>

이런 형식으로 만들어도 괜찮습니다.

위처럼 HTTP 메소드, 그리고 필요한 자원에 대한 명시를 한 URI를 합쳐 API Endpoint 라고 하며,
웹 서비스를 하는 서버의 도메인 주소가 https://umc.com일 경우

***POST https://umc.com/users/login*** 이렇게 요청을 할 경우 로그인이 되는 것이죠.

이제 다음으로 회원 가입과 탈퇴를 설계 해봅시다.

회원 가입의 경우는 POST /users 를 해도 됩니다.

허나, 이것 역시 요구 사항에 따라 달라지는 것으로,
기능 요구 사항에서 회원 가입 외에 사용자가 새로 추가가 되는 경우가 있다면
해당 API와 구분을 해야 하겠죠.

위와 같은 경우를 제외하면 POST /users로 회원 가입을 명시적으로 표현이 가능합니다.

### 🤔 회원 가입은 유저 한 명이 생기는 건데, POST /users/id 아닌가요?

POST /users/id의 형태로 설계를 하려면, 해당 유저를 식별할 값이 존재해야 하는데

회원 가입 이후에서야 해당 유저가 생성이 되기에, 유저를 식별할 값이 API 호출 시점에는 없죠.

따라서 이런 경우는 POST /users/id와 같은 설계가 불가능합니다.

다음으로 회원 탈퇴를 생각해봅시다.

회원 탈퇴는 러프하게 생각하면 아래처럼 설계가 가능하다고 생각할 수 있습니다.

DELETE /users

그러나 요구 사항이
**회원 탈퇴 시 곧바로 데이터베이스에서 삭제가 아니라, 비활성 계정으로 만들고,
추후 계정 복구를 고려**한다면 **DELETE로 설계를 하면 안되죠.**

(지난번에 이야기했던 Soft Delete와 Hard Delete에 관한 개념이 여기에서 다시 연결되는 것입니다.)

이런 경우 데이터베이스에서 사용자 테이블에 status를 active에서 inactive로 변경하는 것이기에

**일부 수정인 PATCH를 활용**해야 합니다.

**PATCH /users**

그런데 이 경우 **회원 정보 수정 API까지 고려해서 설계**를 해야 합니다.

회원 정보 수정 API 역시 닉네임 등 **일부 정보만 수정하는 것**이기에

PATCH를 사용하며, **PATCH /users 로 설계가 가능**하겠죠.

이런 상황에서 저 같은 경우,
**회원 정보 수정은 PATCH /users/id** 로 **특정 유저의 정보 수정임을 명시적으로 표현**하고,
**회원 탈퇴**는 **PATCH /users** 로 표현하기도 합니다.

허나 프론트엔드 개발자 분들이 저런 설계를 헷갈려 하실 수도 있어서,
회원 탈퇴의 경우 PATCH /users 뒤에 추가적인 정보를 더해 설계를 할 수도 있습니다.

이렇듯, **API 설계에는 절대적인 정답은 없고**

위에서 나열한 5개의 규칙을 지키되,
요구 사항에 따라 **피치 못한 경우는 무조건 저 규칙을 따르지 않아도 됩니다.**

**결국 프론트엔드 개발자 분들이 우리의 API 설계를 보고
쉽게 무슨 API인지 감을 잡으면 되는 거에요!**

### 👉 리소스 간 연관 관계가 있는 경우

예를 들어 교과목이 **한 명의 사용자(교사)가 여러 개의 교과목을 강의 할 수 있다**고 하고,

**교사와 교과목이 1 : N 관계인 경우**

이런 상황에서 **교과목의 목록을 조회하는 API를 설계**한다고 가정해봅시다.

**교과목은 교사와 1 : N 관계**를 가지므로, 아래처럼 설계를 할 수 있습니다.

편의를 위해 사용자는 오로지 교사만 있다고 하겠습니다.

<aside>
🔑 **/users/subjects**

</aside>

이런 식으로 **교사가 여러 개의 과목을 강의**하기에 **계층 관계는 교사 다음 교과목**으로 잡고,
**uri상에 교사가 더 계층 관계 상 우선이 된다는 것을 표현**할 수 있습니다.

만약, **특정 교사의 교과목 목록을 보고 싶다**면 어떻게 할 수 있을까요?

<aside>
🔑 **/users/id/subjects**

</aside>

이렇게 설계가 가능합니다.

가운데 id는 아래에서 path variable을 설명하면서 다시 설명 하도록 하겠습니다.

만약, **교과목 하나 단건 조회 API를 설계**한다면?

이런 경우는 

<aside>
🗣 **특정 교사의 특정 교과목이 더 의미가 잘 전달이 되는지,
아니면 그저 특정 교과목이 더 의미가 잘 전달이 되는지.**

**요구 사항에 더 맞는 설계를 선택하면 됩니다.**

</aside>

<aside>
🔑 **/users/id/subjects/id**

(id 부분은 아래 path variable에서 **다시 설명 할 예정**입니다. 왜 id를 두 번 쓰는지 의문이 들더라도 조금만 기다려주세요.)

혹은

**/users/subjects/id**

</aside>

이렇게 설계가 가능합니다.

### 🤔 N : M 관계는?

API 설계에서 가장 짜증나는 경우😱입니다.

게시글과 해시태그가 이런 경우죠.

앞선 주차 워크북에서 게시글과 해시태그가 N : M 관계라고 했죠?

이런 경우 계층 관계를 한눈에 보기가 매우 힘들게 됩니다.

<aside>
🤔 **/articles/hash-tags**가 나을 지

**/hash-tags/articles**가 나을 지 

</aside>

난감합니다.

이런 경우는 **비즈니스 로직상 더 중요한 대상을 계층 관계에서 앞에 두는 방법**이 있습니다.

사실 위의 경우는 직감적으로 **해시태그는 부수적인 것**이고,
**게시글이 서비스에서 더 중요한 역할을 한다는 것**은 쉽게 느낄 수 있죠.

이런 경우는 

<aside>
🔑 **/articles/hash-tag**

</aside>

이렇게 설계가 가능합니다.

이처럼 API 설계에서도 기획의 요구 사항이 영향을 끼치므로

반드시 PM, 프론트 개발자 분들과 많은 소통을 하여 설계를 하는 것이 좋습니다.

---

## 세부적인 API 설계

이제 세부적인 API 설계를 어떻게 할지 생각을 해봅시다.

이제, 아래의 키워드를 API 설계에서 포함해서 고려를 할 것입니다.

<aside>
🌟  1.  **path variable**

1. **query string**
2. **request body**
3. **request header**
</aside>

**위의 4개 중 API endpoint에 포함이 되는 것은 path variable 하나 뿐입니다.**

사실 **API Endpoint**는 간략하게 **[이런 역할을 하는 API야!]** 정도만 알려주는 것입니다.

예를 들어

회원 가입을 한다고 합시다.

POST /users 정도로 엔드포인트 설계는 끝이 나겠죠.

그러나 위의 정보 만으로는 부족한 것이 있습니다.

### 🤔 회원 가입이란 , 회원 정보를 새로 저장하는 건데, 무슨 정보를 저장해?

그렇죠?

엔드 포인트 하나 만으로는 실제 동작 수행에 필요한 정보를 표현할 수 없죠.

**이런 경우 바로 위의 4가지**를 사용하게 됩니다. (path variable, query string, request body, request header)

우선 **path variable**과 **query string**을 알아봅시다.

### Path Variable

---

이런 경우가 있을 수 있겠죠.

> ***게시글 하나 상세 조회 API***
> 

위의 경우 곧바로 단건 조회, 즉 GET에 단건 조회라는 것은 빠르게 캐치가 가능합니다.

여기서 어떻게 특정 게시글임을 서버에게 전달이 가능할까요?

다시 말해, 서버에게 어떻게 원하는 게시글을 식별할 수 있는 데이터를 넘길 수 있을까요?

**이런 경우 path variable을 사용**합니다.

> **단 하나, 특정 대상을 지목할 때**
> 

/users/articles/id 처럼 id에 게시글의 식별 값을 넣어서 전달하게 됩니다.

따라서 실제로는 아래와 같겠죠.

**GET https://umc.com/users/articles/4   ← 저 4에 주목!**

여기서 저 4가 데이터베이스 상에서 게시글의 기본키라는 것을 캐치 한다면 잘 이해한 것입니다.

따라서

**/users/articles/id**에서 id는 진짜 문자 그대로 id가 아니라 **게시글의 식별 값을 의미**하죠.

따라서 **실제 API 명세서에서는 아래처럼 표현**합니다.

<aside>
🔑 GET /users/articles/**{articleId}**

</aside>

위 처럼 **{ }**(중괄호)로 감싸는 부분은 path variable을 의미하고,
그냥 id 보다는 articleId처럼 **더 명확히 표시**해주는 것이 더 좋습니다.

그리고 **단어 구분을 -를 사용해서 한다**고 했으니

<aside>
🔑 GET /users/articles/**{article-id}**

</aside>

이렇게 해도 됩니다. 그런데 꼭 RESTful 설계를 타이트하게 따르지 않아도 되기에

**articleId** **이렇게 표현을 해도 됩니다.**

<aside>
🔑 GET /users/articles/**{articleId}**

</aside>

### Query String

---

쿼리 스트링은 언제 사용이 되냐,

> **게시글 중 이름에 umc가 포함된 게시글들을 조회하려고 할 때**
> 

이런 경우, **1개가 될 수도 있고 여러 개가 될 수도** 있잖아요?

따라서 단 하나만 조회하는 path variable을 사용하는 것은 아니고,
**query string을 활용**하는 것입니다.

쿼리 스트링은 보통 **검색 조회** 때 사용이 되며 따라서 **GET 요청에서 사용**이 됩니다.

<aside>
🔑 GET /users/articles**?name=umc**

</aside>

위처럼 **name이 umc**라는 것을 전달 할 수 있고,

만약 **전달 할 정보가 여러 개**일 경우 아래와 같이

<aside>
🔑 GET /users/articles**?name=umc&owner=ddol**

</aside>

이런 식으로 &를 통해 쿼리 스트링으로 전달을 하려는 값을 여러 개 연결 할 수 있습니다.

❗ 주의할 점은, **쿼리 스트링은 API 엔드 포인트에 포함이 되지 않기에**

**엔드 포인트 자체**는 **GET /users/articles** 이렇게 설계를 해야 합니다.

### Path Variable & Query String 비교 정리

---

| **구분** | **Path Variable** | **Query String** |
| --- | --- | --- |
| 목적 | 특정 리소스 식별 | 검색, 필터링, 페이징 |
| 개수 | 보통 1~2개 | 제한 X |
| 예시  | /users/{id} | /users?name=umc&page=2 |

이제 어떤 상황에서 무엇을 써야하는지 감이 오시죠?

### Request Body

---

POST 방식의 경우는 어떻게 서버로 데이터를 전달할까요?

POST는 조회가 아닌, 생성을 위해 사용하기도 하기에 url에 해당 정보들을 노출하는 것은 굉장히 

위험할 수 있습니다.

따라서 **url에 노출이 되지 않고 request body에 해당 데이터를 담을 수 있으며,**
보통 **json의 형태** 혹은 **form-data 형태**로 보내게 됩니다.

**form-data 형태의 전송**은 12주차 AWS S3에서 더 자세히 다룹니다.

예를 들어 회원 가입 시 아래의 정보가 필요하다고 합시다.

1. 이름
2. 전화번호
3. 닉네임

이럴 경우 request body에 위의 정보를 json으로 담아서 서버로 전송하게 됩니다.

```json
{
	"name" : "최용욱",
	"phoneNum" : "010-1111-2222",
	"nickName" : "ddol",
}
```

### Request Header

---

request header는 서버와 전송 시 메타데이터,

즉, **전송에 관련된 기타 정보들이 담기는 부분**입니다.

body에 담기는 데이터의 형식이 json인지, 아니면 form-data인지를 담기도 하고
혹은 데이터를 담을 수 도 있습니다.

대표적으로 로그인이 되었다는 것을 알려주기 위한 토큰을 헤더에 담기도 합니다!

## API 설계 예시

예를 들어 **닉네임 변경(사용자 정보 변경) API**에 대한 설계를 한다고 할 경우,
아래와 같은 정보를 명시할 수 있습니다.

### API Endpoint

PATCH /users/{userId}

### Request Body

```json
{
	"nickname" : "ddol"
}
```

### Request Header

Authorization : accessToken (String)

accessToken은 로그인 된 사용자가 **나 로그인 된 상태야!** 하고 알려주는 것으로

보통 Authorization이라는 키에 대한 값으로 헤더에 담아서 서버로 보내주게 됩니다.

### Query String

필요 없음

**API 응답에 대한 것은 추후 7주차**에서 다루게 됩니다.