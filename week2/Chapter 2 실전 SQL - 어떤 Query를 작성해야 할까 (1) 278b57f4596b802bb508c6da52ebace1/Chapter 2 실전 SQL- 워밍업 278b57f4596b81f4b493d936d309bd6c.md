# Chapter 2. 실전 SQL- 워밍업

![연습은 1주차 ERD로 한번 해보겠습니다. ](Chapter%202%20%EC%8B%A4%EC%A0%84%20SQL-%20%EC%9B%8C%EB%B0%8D%EC%97%85%20278b57f4596b81f4b493d936d309bd6c/image.png)

연습은 1주차 ERD로 한번 해보겠습니다. 

### 1. 기본 조회

기본적인 조회 기능입니다.

<aside>
🔑 “소설” 카테고리의 모든 책을 조회하자.

</aside>

- 예시입니다. 꼭 고민해 본 후 토글을 열어주세요!
    
    ```sql
    SELECT b.name, b.description
    FROM book b
    JOIN book_category bc ON b.book_category_id = bc.id
    WHERE bc.name= "소설";
    ```
    
    SELECT 문은 데이터를 검색하는 기본 문장이죠!
    
    이 부분은 간단해서 코드 설명은 자세히 하지 않겠습니다.
    

### 2. 집계 함수

이번에는 집계 함수를 사용해 보겠습니다.

<aside>
🔑 회원별 대여 횟수 상위 5명을 조회하자.

</aside>

- 예시
    
    일단 어떤 테이블을 조인해야 할 지 먼저 생각해 본다면, rent 테이블과 member 테이블일 거에요.
    
    ```sql
    SELECT m.name, COUNT(*) as rent_count
    FROM member m
    JOIN rent r ON m.id=r.member_id 
    GROUP BY m.id, m.name
    ORDER BY rent_count DESC
    LIMIT 5;
    ```
    
    여기서 GROUP BY는 회원별로 데이터를 그룹화해주고, GROUP BY에서 id와 name을 모두 써준 이유는 SELECT에서 name을 조회하기 때문입니다.
    
    COUNT(*)는 집계함수고, GROUP BY 때문에 각 회원별로 집계가 이루어집니다! 
    

### 3. 복합 JOIN

이제 슬슬 쿼리가 복잡해지기 시작합니다. 

<aside>
🔑 각 회원이 좋아요를 누른 책의 카테고리별 분포를 조회하자.

</aside>

결과 예시 ⬇️

전하경 | 소설   | 3
전하경 | 에세이 | 1

재서 | 소설   | 5
재서 | 만화   | 2

- 예시
    
    이 쿼리 문제는 다중 JOIN과 GROUP BY를 사용하면 좋을 것 같아요.
    
    ```sql
    SELECT m.name, bc.name as category, COUNT(*) as like_count
    FROM member m
    JOIN book_likes bl ON m.id=bl.member_id
    JOIN book b ON bl.book_id=b.id
    JOIN book_category bc ON b.book_category_id=bc.id
    GROUP BY m.id, m.name, bc.id, bc.name;
    ```
    
    시작점은 member 테이블이에요.
    
    member 테이블을 통해 book_likes, book, book_category에 차례차례 접근합니다.
    
    그리고 이를 GROUP BY를 이용해 회원별+ 카테고리별로 그룹화합니다.
    
    그리고 각 그룹에서 좋아요 개수를 세는 거에요. 
    

### 4. 서브쿼리

같은 문제를 복합 JOIN을 써서 한 번, 서브쿼리를 써서 한 번 구현해봅시다.

<aside>
🔑 각 회원이 좋아요를 누른 책의 카테고리별 분포를 조회하자.

</aside>

- 예시
    
    ```sql
    SELECT m.name, bc.name as category, 
    ( SELECT COUNT(*) 
    FROM book_likes bl 
    JOIN book b ON bl.book_id=b.id 
    WHERE bl.member_id = m.id AND b.book_category_id=bc.id) as like_count 
    FROM member m
    CROSS JOIN book_category bc
    WHERE (SELECT COUNT(*) 
    				FROM book_likes bl
    				JOIN book b ON bl.book_id=b.id
    				WHERE bl.member_id = m.id AND b.book_category_id = bc.id) > 0;
    ```
    
    일단 FROM member m CROSS JOIN book_category bc는 모든 회원과 모든 카테고리의 조합을 만들어줍니다. 회원이 100명, 카테고리가 10개라면 1000개의 조합을 만들어주겠죠?
    
    그리고 SELECT 절의 서브쿼리를 한번 봅시다.
    
    이는 각 회원 그리고 카테고리의 조합마다 실행되는 서브쿼리입니다.
    
    “이 회원이 이 카테고리 책에 누른 좋아요 개수”를 계산합니다.
    
    WHERE 절에서는 좋아요 개수가 0인 조합은 제외해서 실제로 좋아요를 누른 조합만 결과에 포함되게 합니다.
    
    그런데 문제점이 있죠?
    
    맞습니다. 같은 서브쿼리가 두 번 실행됩니다.
    
    또 CROSS JOIN으로 불필요한 조합까지 다 만들고 나서 필터링하기도 하구요.
    
    이 방법에서는 복합 JOIN 방식을 쓰는게 좀 더 효율적이겠네요.
    

사실 개발을 진행하다 보면 이것보다 훨씬 복잡하고 난해한 ERD, 쿼리들을 마주하는 상황이 생길 수도 있습니다. 

하지만 지금 연습한 기본기들이 탄탄하다면, 복잡한 문제도 결국 작은 단위들의 조합임을 알 수 있습니다.

ORM을 사용한다고 하더라도 쿼리와 마주할 상황은 분명히 생기고, 그 때 이때의 경험들이 큰 도움이 되어줄 수 있습니다.

그렇게 될 수 있는 그 날까지 화이팅입니다 😊

---

Copyright © 2025 재서(전하경) All rights reserved.