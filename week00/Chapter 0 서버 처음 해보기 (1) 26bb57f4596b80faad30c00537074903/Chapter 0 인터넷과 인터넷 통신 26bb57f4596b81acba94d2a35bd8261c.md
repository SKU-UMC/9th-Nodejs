# Chapter 0. 인터넷과 인터넷 통신

# 인터넷

인터넷이란 Data를 전달하는 장치들이 이루는 거대한 network 망을 의미하며 Application에게 통신 서비스를 제공하는 존재를 의미합니다. (요약하자면 데이터를 전달해 주는 망이라고 생각해 주시면 될 것 같아요!)

## 인터넷 구성

인터넷은 여러 형태의 network와 그 안에 sub-network로 구성이 됩니다. 또한 network는 다양한 entity인 Network Edge, Access network, Network Core 등으로 이루어져 있습니다.

### Network Edge

- 끝에 있는 entity를 의미하며 , End System으로 구성. End System은 호스트(Host)라고도 불립니다.
- 역할: Application Layer에서 데이터를 생성하거나 수신하는 주체입니다.
- 예시: web browser, email client, 스마트폰, 노트북, 우리가 앞으로 개발할 서버(실제 application) 등

End-to-End 통신의 시작점 또는 끝점입니다. 

### Access Network

- End system이 Internet의 첫 부분과 연결되는 구간입니다.
- 역할: End System을 ISP(Internet Service Provider) 또는 로컬 네트워크에 연결하는 역할을 합니다.
- 예시: 우리가 인터넷에 접속할 때 사용하는 랜선, 와이파이, 셀룰러 기지국 등

### Network Core

- Network의 핵심 부분입니다.
- 역할: End System의 정보를 최적 경로로 전달하는 역할을 합니다.
- 핵심 구성 요소
    - 라우터(Router) : 패킷의 목적지를 보고 다음 경로로 전달
    - 스위치(Switch): 로컬 네트워크 내에서 프레임 전달

![스크린샷 2024-09-04 오후 4.25.42.png](Chapter%200%20%EC%9D%B8%ED%84%B0%EB%84%B7%EA%B3%BC%20%EC%9D%B8%ED%84%B0%EB%84%B7%20%ED%86%B5%EC%8B%A0%2026bb57f4596b81acba94d2a35bd8261c/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2024-09-04_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_4.25.42.png)

 

 한 문장으로 정리하자면, End System → Access Network → Network Core → Access Network → End System 순서로 데이터가 흐르는 것이죠. 

각 용어들을 자세히 외울 필요는 없고 간단하게 인터넷의 구성하는 요소들에는 이러한 것들이 있고 각 구성요소들이 어떠한 역할을 하는구나 정도만 이해해 주시면 될 것 같습니다.

---

## 인터넷 통신

 이제 인터넷이 어떠한 것으로 구성이 되는지 알아보았으니 본격적으로 어떻게 클라이언트와 서버가 서로 통신을 하는지 알아보겠습니다.

 인터넷 통신을 간단히 말하자면 End system 간 Packet(=Datagram)을 주고받는 것이라고 말할 수 있습니다.

### Packet(=Datagram)

Packet(패킷)은 인터넷상에서 장치들이 서로 통신할 때 전송하는 데이터 조각입니다.

간단하게 설명하자면 상대에게 전송할 데이터가 담긴 것이라고 생각하시면 될 것 같습니다. (TCP, UDP 인지에 따라 IPv4, IPv6에 인지에 따라 형태가 달라지기 때문에 정확한 형태는 게시하지 않겠습니다.)

근데 전 세계에는 정말 다양한 기기들이 있는데 어떻게 상대 기기를 식별하여서 패킷을 보낼 수 있는 것일까요?

![스크린샷 2024-09-04 오후 4.27.17.png](Chapter%200%20%EC%9D%B8%ED%84%B0%EB%84%B7%EA%B3%BC%20%EC%9D%B8%ED%84%B0%EB%84%B7%20%ED%86%B5%EC%8B%A0%2026bb57f4596b81acba94d2a35bd8261c/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2024-09-04_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_4.27.17.png)

이에 대해 알기 위해서는 **IP**에 대한 개념이 필요합니다.

### IP

IP란 Internet Protocol의 약자로 Network Layer에서 작용을 하며 인터넷상에서 **유일하게** 상대를 식별할 수 있는 수단입니다. (간단하게 말하자면 인터넷상의 주소라고 생각하시면 될 것 같아요.)

클라이언트(end system)는 요청을 보낼 때 패킷에 IP 주소를 담고 Access Network를 통해 Network Core로 보냅니다.

 패킷을 받은 router는 자신의 Network Layer에서 패킷 안에 있는 IP를 확인 후 더 알맞은 위치의 router로 보내게 되고 그렇게 최종적으로 Network Edge에 도착하면 Network Layer에서 패킷을 확인 후 도착지의 IP가 자신의 IP가 옳다면 Transport Layer로 올리고 아니라면 다른 곳으로 보내게 됩니다.

![스크린샷 2024-09-04 오후 4.28.18.png](Chapter%200%20%EC%9D%B8%ED%84%B0%EB%84%B7%EA%B3%BC%20%EC%9D%B8%ED%84%B0%EB%84%B7%20%ED%86%B5%EC%8B%A0%2026bb57f4596b81acba94d2a35bd8261c/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2024-09-04_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_4.28.18.png)

(위의 그림은 번호가 0.0.0 이런 식으로 나누었는데 IPv4가 가장 많이 쓰이기 때문에 실제로 프로젝트를 할 때는 0.0.0.0 이런 식의 형태가 많이 나올 것입니다.)

 

위에 동작들을 보면 router들이 다른 정보 없이 패킷의 정보만을 해석하여 목적지를 추적한다는 것을 알 수 있습니다.

위와 같은 방식으로 패킷이 이동을 한다면 다른 기기의 정보를 알 수 없기 때문에 여러 가지 문제점을 생각할 수 있을 겁니다.

1. **만약 상대의 컴퓨터가 꺼져있다면?**
2. **만약 중간에 패킷이 소실이 된다면?**
3. **뒤에 보낸 패킷이 먼저 도착한다면?**
4. **컴퓨터에 프로그램이 여러 개가 켜져 있다면?**

이를 해결하기 위해서는 PORT와 TCP, UDP가 필요합니다.

### PORT

(원래는 TCP, UDP 프로토콜 안에 PORT가 포함되는 것인데 PORT를 먼저 설명하는 것이 더 쉬울 것 같아 먼저 설명하도록 하겠습니다.)

문제 4번처럼 UMC 웹사이트와 MySQL이라는 프로그램이 같이 켜져 있다고 가정해 봅시다.

Network Layer에서 자신의 IP 임을 확인하였지만 어느 프로그램으로 packet을 이동시켜야 하는지 알 수 없습니다.

![스크린샷 2024-09-04 오후 4.29.32.png](Chapter%200%20%EC%9D%B8%ED%84%B0%EB%84%B7%EA%B3%BC%20%EC%9D%B8%ED%84%B0%EB%84%B7%20%ED%86%B5%EC%8B%A0%2026bb57f4596b81acba94d2a35bd8261c/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2024-09-04_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_4.29.32.png)

이때 필요한 것이 PORT입니다. 

 

 PORT란 같은 IP 내에서 프로세스를 구분하는 데 사용하는 번호를 의미합니다. 대표적으로 HTTP의 80 HTTPS의 443 등이 존재합니다. 

 위의 상황에서 PORT 번호를 적용하여서 본다면 밑의 그림처럼 해결이 가능합니다. (실제 웹사이트인 [https://neordinary.co.kr:443](https://neordinary.co.kr:443) 을 눌러 보시면 neordinary 웹사이트로 연결되는 모습을 볼 수 있습니다. (우리가 보는 원래 웹사이트에도 포트 번호가 존재하지만 http의 80이나 https 443은 이미 정해져있기 때문에 생략한 것입니다.))

![스크린샷 2024-09-04 오후 4.38.10.png](Chapter%200%20%EC%9D%B8%ED%84%B0%EB%84%B7%EA%B3%BC%20%EC%9D%B8%ED%84%B0%EB%84%B7%20%ED%86%B5%EC%8B%A0%2026bb57f4596b81acba94d2a35bd8261c/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2024-09-04_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_4.38.10.png)

위 그림으로 보자면 UMC 웹사이트의 주소는 [https://100.111.100:443](http://100.111.100:443) 일 것이고 이 중 100.111.100은 IP, 443은 PORT가 됩니다.

참고로 [https://neordinary.co.kr:443](https://neordinary.co.kr:443) 주소에서 neordinary.co.kr은 도메인(IP주소를 우리가 보기 쉽게 문자 등으로 바꾼 것)주소이고 443이 포트 입니다!

### TCP

아직 1, 2, 3번 문제가 남았습니다.

이 문제들을 해결 가능한 것이 TCP입니다.

TCP란 Transmission Control Protocol(전송 제어 프로토콜)의 약자로 연결 보증을 해줌으로써 위의 1, 2, 3번 문제를 해결할 수 있습니다. (Transport Layer에서 사용이 됩니다.)

**3 way-handshake**

1번 문제처럼 상대방의 컴퓨터 서버가 꺼져있다고 가정해 보겠습니다.

보내는 입장에서는 packet에 도착지의 IP와 PORT만 넣어서 보내고 router는 IP와 PORT를 보고 목적지로 보냅니다.

하지만 목적지의 컴퓨터는 꺼져있기 때문에 메시지를 받을 수 없습니다.

![스크린샷 2024-09-04 오후 4.05.40.png](Chapter%200%20%EC%9D%B8%ED%84%B0%EB%84%B7%EA%B3%BC%20%EC%9D%B8%ED%84%B0%EB%84%B7%20%ED%86%B5%EC%8B%A0%2026bb57f4596b81acba94d2a35bd8261c/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2024-09-04_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_4.05.40.png)

그렇기에 데이터를 보내기에 앞서 클라이언트는 상대방이 있는지 확인해야 합니다.

그때 사용하는 것이 3 way-handshake입니다.

클라이언트는 받는 곳에게 syn을 쏘고 그것을 받은 상대방은 받을 수 있는 상태라는 ack와 보내는 쪽도 받는 것이 가능한가를 물어보는 syn를 보냅니다. 클라이언트가 syn을 받고 온전한 상태라는 ack를 보내게 되면 3 way-handshake가 완성이 되며 서로 받을 수 있는 상태라는 것이 보증이 되게 됩니다. (syn와 ack는 서로의 상태가 괜찮은 지를 묻고 답하는 거라고 생각하시면 될 것 같아요!) 

![스크린샷 2024-09-04 오후 6.05.21.png](Chapter%200%20%EC%9D%B8%ED%84%B0%EB%84%B7%EA%B3%BC%20%EC%9D%B8%ED%84%B0%EB%84%B7%20%ED%86%B5%EC%8B%A0%2026bb57f4596b81acba94d2a35bd8261c/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2024-09-04_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_6.05.21.png)

실제로는 router를 타고 가야 하지만 보기 쉽게 화살표로 표시하였습니다.

![스크린샷 2024-09-05 오후 2.17.17.png](Chapter%200%20%EC%9D%B8%ED%84%B0%EB%84%B7%EA%B3%BC%20%EC%9D%B8%ED%84%B0%EB%84%B7%20%ED%86%B5%EC%8B%A0%2026bb57f4596b81acba94d2a35bd8261c/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2024-09-05_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_2.17.17.png)

3 way handshake만 요약하면 이렇습니다.

마지막으로 좀 더 쉽게 일상적인 예시로 이해해 볼까요?

두 사람이 전화로 대화를 하는 상황을 한번 가정해 봅시다.

1. 클라이언트는 서버에게 “대화하고 싶어요!” 라고 먼저 신호를 보냅니다. (SYN)
2. 그럼 서버는 클라이언트에게 “난 할 수 있어. 너도 괜찮아?” 라고 신호를 다시 보내요 (SYN+ACK) 
    
    여기서 난 준비되었다는 것이 SYN, ACK가 신호를 잘 받았다는 뜻입니다.
    
3. 그럼 다시 클라이언트는 서버에게 나도 괜찮다는 응답을 보냅니다 (ACK) 

이제 양쪽 다 대화 준비가 끝났다는 것을 확인했기 때문에 본격적인 데이터를 주고받을 수 있습니다. 

이 과정을 TCP 3 way handshake라고 부르는 것입니다. 

**데이터 전달 보증**

2번 문제처럼 패킷이 중간에 소실되어 있다고 가정해 보겠습니다.

![스크린샷 2024-09-05 오전 11.44.42.png](Chapter%200%20%EC%9D%B8%ED%84%B0%EB%84%B7%EA%B3%BC%20%EC%9D%B8%ED%84%B0%EB%84%B7%20%ED%86%B5%EC%8B%A0%2026bb57f4596b81acba94d2a35bd8261c/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2024-09-05_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%258C%25E1%2585%25A5%25E1%2586%25AB_11.44.42.png)

보내는 입장이나 받는 입장에서는 패킷이 소실되었는지 아직 도착을 안한 건지 알 수 없습니다.

그래서 받았음을 알려줌으로써 이를 해결합니다.

![스크린샷 2024-09-05 오후 3.23.26.png](Chapter%200%20%EC%9D%B8%ED%84%B0%EB%84%B7%EA%B3%BC%20%EC%9D%B8%ED%84%B0%EB%84%B7%20%ED%86%B5%EC%8B%A0%2026bb57f4596b81acba94d2a35bd8261c/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2024-09-05_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_3.23.26.png)

**순서 보장**

보통 패킷을 보낼 때 일정량 이상이 된다면 끊어서 보냅니다.

이때 3번 문제처럼 뒤에서 보낸 패킷이 먼저 도착할 수도 있습니다. 

예를 들어 Hello World라는 정보를 서버로 보내는 데 크기가 너무 커서 Hello와 World로 나누어서 보낸다고 가정해 봅시다. 그때 만약 순서가 뒤집힌다면 올바른 정보가 가지 못할 것입니다.

![스크린샷 2024-09-05 오전 11.52.42.png](Chapter%200%20%EC%9D%B8%ED%84%B0%EB%84%B7%EA%B3%BC%20%EC%9D%B8%ED%84%B0%EB%84%B7%20%ED%86%B5%EC%8B%A0%2026bb57f4596b81acba94d2a35bd8261c/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2024-09-05_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%258C%25E1%2585%25A5%25E1%2586%25AB_11.52.42.png)

TCP는 패킷에 sequence number라는 순서를 붙임으로써 이 문제를 해결합니다.

도착한 패킷의 sequence number를 분석해서 만약 순서가 이상하다면 다시 보내달라고 하여서 문제를 해결합니다.

![스크린샷 2024-09-05 오후 1.18.24.png](Chapter%200%20%EC%9D%B8%ED%84%B0%EB%84%B7%EA%B3%BC%20%EC%9D%B8%ED%84%B0%EB%84%B7%20%ED%86%B5%EC%8B%A0%2026bb57f4596b81acba94d2a35bd8261c/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2024-09-05_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_1.18.24.png)

### UDP

UDP란 User Datagram Protocol(사용자 데이터그램 프로토콜)의 약자로 TCP와는 달리 3 way handshake나 데이터 전달 보증, 순서 보장 없이 기존의 IP에 PORT와 체크 섬(데이터가 맞는 지만 확인)만 추가한 프로토콜입니다. TCP에 비해 신뢰성이 떨어지지만 검증하는 부분이 적어지기에 그만큼 더 빠르다는 장점이 있습니다.

(UMC에서는 웹 서버가 많이 사용하는 TCP를 주로 다루기에 UDP의 더 정확한 설명은 하지 않겠습니다.)

---

### 전체적인 흐름 요약

1. 클라이언트는 서버와 통신하기 위해 TCP 3 way handshake를 수행합니다. 이 과정을 통해 양쪽 모두 데이터를 주고받을 준비가 되었는지 확인합니다.
2. 데이터 전송 - Access Network → 인터넷
    
    연결이 완료되면 클라이언트는 데이터, IP, PORT 번호 등 다양한 정보를 담은 패킷을 생성해 Access Network(와이파이, 유선 LAN)을 통해 인터넷으로 보냅니다.
    
3. 패킷 전달 - Network Core
    
    패킷이 Network Core에 도달하면, 여러 라우터(router)를 거쳐 목적지를 향해 이동합니다. 이때 라우터는 패킷의 IP 주소를 보고 다음 라우터로 경로를 설정합니다. 
    
4. 도착- 서버 측 Network Edge
    
    목적지(서버)에 도달하면, 패킷은 Physical Layer→ Data Link Layer → Network Layer 순으로 각 계층을 거칩니다. 
    
5. 패킷 처리- IP & PORT 확인
    - Network Layer에서는 IP 주소를 확인해 올바른 수신지인지를 판단합니다
    - Transport Layer에서는 PORT 번호를 확인해 해당 포트에서 실행 중인 애플리케이션으로 데이터를 전달합니다.
6. 응답 전송 (필요 시) 
    
    서버가 요청을 처리한 후, 클라이언트에게 응답이 필요하다면 역방향으로 다시 패킷을 생성하여 클라이언트에게 전달합니다.
    
    (역시 같은 방식으로 인터넷망을 통해 이동합니다.) 
    

![스크린샷 2024-09-05 오후 2.11.16.png](Chapter%200%20%EC%9D%B8%ED%84%B0%EB%84%B7%EA%B3%BC%20%EC%9D%B8%ED%84%B0%EB%84%B7%20%ED%86%B5%EC%8B%A0%2026bb57f4596b81acba94d2a35bd8261c/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2024-09-05_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_2.11.16.png)